package xyz.ressor;

import xyz.ressor.commons.exceptions.RessorBuilderException;
import xyz.ressor.config.RessorConfig;
import xyz.ressor.ext.ServiceExtension;
import xyz.ressor.service.RessorService;
import xyz.ressor.service.ServiceManager;
import xyz.ressor.service.error.ErrorHandler;
import xyz.ressor.service.proxy.ProxyContext;
import xyz.ressor.service.proxy.ServiceProxyBuilder;
import xyz.ressor.source.ResourceId;
import xyz.ressor.source.Source;
import xyz.ressor.source.fs.FileSystemResourceId;
import xyz.ressor.source.fs.FileSystemSource;
import xyz.ressor.translator.Translator;
import xyz.ressor.translator.TranslatorHelper;

import java.io.InputStream;
import java.nio.charset.Charset;
import java.nio.file.Path;
import java.util.LinkedList;
import java.util.function.Function;

import static java.lang.String.format;
import static java.nio.charset.StandardCharsets.UTF_8;
import static xyz.ressor.commons.utils.RessorUtils.firstNonNull;

/**
 * The builder for the Ressor service proxy class, which will be built and loaded by a {@link ClassLoader} at runtime.
 * <p/>
 * <p/>
 * If <b>T</b> is a class, it will be extended by the proxy class.
 * If <b>T</b> doesn't have a default constructor, Ressor will scan it for the mostly short and public constructor available, which will be used
 * for the proxy instance creation (which happens once). This can't be avoided since this is how the JVM inheritance mechanism works - we should call at least one constructor of a super type.
 * <p/>
 * Otherwise, you can mark your constructor with {@link xyz.ressor.commons.annotations.ProxyConstructor} annotation, which will tell Ressor
 * to use it explicitly. If constructor has parameters, Ressor will guess and pass the default ones, based on the underlying parameter type
 * (<b>null</b> for object references, 0 for numbers, empty collections, etc). Alternatively, you can provide your own param values with {@link #proxyDefaultArguments(Object...)}.
 * <p/>
 * By default, Ressor will also find the constructor to create the actual instances of your service. You can alternatively mark
 * the desired constructor/factory method with {@link xyz.ressor.commons.annotations.ServiceFactory} annotation. It must have a single parameter,
 * which will be of type of your selected {@link Translator}.
 * <p/>
 * <p/>
 * If <b>T</b> is an interface, it will be implemented by the proxy class.
 * In that case you should provide a {@link #factory(Function)} which will be in charge of creating the actual instances of your service based
 * on the {@link Translator}.
 *
 * @param <ServiceType> service public type
 */
public class RessorBuilder<ServiceType, DataType> {
    private final ServiceProxyBuilder proxyBuilder;
    private final Class<ServiceType> type;
    private final RessorConfig config;
    private final FileSystemSource fileSystemSource;
    private final ServiceManager serviceManager;
    private Translator<InputStream, DataType> translator;
    private Function<DataType, ? extends ServiceType> factory;
    private Source source;
    private ResourceId resource;
    private ServiceType initialValue;
    private boolean isAsync;
    private boolean gzipped = false;
    private ClassLoader classLoader;
    private LinkedList<ServiceExtension> extensions = new LinkedList<>();
    private Object[] proxyDefaultArguments;
    private ErrorHandler errorHandler;

    public RessorBuilder(Class<ServiceType> type, RessorConfig config, FileSystemSource fileSystemSource,
                         ServiceManager serviceManager) {
        this.type = type;
        this.config = config;
        this.fileSystemSource = fileSystemSource;
        this.proxyBuilder = new ServiceProxyBuilder(config.isCacheClasses());
        this.serviceManager = serviceManager;
    }

    /**
     * Your custom data translator implementation. The resulting type of translator will be provided
     * to your service factory.
     */
    public <DT> RessorBuilder<ServiceType, DT> translator(Translator<InputStream, DT> translator) {
        this.translator = (Translator<InputStream, DataType>) translator;
        return (RessorBuilder<ServiceType, DT>) this;
    }

    /**
     * Your custom service factory. Service factory is responsible for creating your service instance,
     * accepting the resulting data generated by the {@link Translator}.
     */
    public RessorBuilder<ServiceType, DataType> factory(Function<DataType, ? extends ServiceType> factory) {
        this.factory = factory;
        return this;
    }

    /**
     * Tells Ressor to use the given file as a data {@link Source}.
     */
    public RessorBuilder<ServiceType, DataType> fileSource(String filePath) {
        this.source = fileSystemSource;
        this.resource = new FileSystemResourceId(filePath);
        return this;
    }

    /**
     * Tells Ressor to use the given file as a data {@link Source}.
     */
    public RessorBuilder<ServiceType, DataType> fileSource(Path filePath) {
        this.source = fileSystemSource;
        this.resource = new FileSystemResourceId(filePath);
        return this;
    }

    /**
     * Provide your custom data source to the Ressor to use for your service.
     */
    public RessorBuilder<ServiceType, DataType> source(Source source) {
        this.source = source;
        return this;
    }

    /**
     *
     * @param resource
     * @return
     */
    public RessorBuilder<ServiceType, DataType> resource(ResourceId resource) {
        this.resource = resource;
        return this;
    }

    /**
     * Whether the source data is expected to be GZIP encoded.
     */
    public RessorBuilder<ServiceType, DataType> gzipped() {
        this.gzipped = true;
        return this;
    }

    /**
     * The initial default instance of your service. It will be used by Ressor before the first
     * {@link Source#load(ResourceId)} )} is happened.
     *
     * Make sense only if {@link #asyncInitialReload()} is used.
     */
    public RessorBuilder<ServiceType, DataType> initialInstance(ServiceType initialValue) {
        this.initialValue = initialValue;
        return this;
    }

    /**
     * Whether to perform the initial data load asynchronously. Defaults to false.
     */
    public RessorBuilder<ServiceType, DataType> asyncInitialReload() {
        this.isAsync = true;
        return this;
    }

    /**
     * ClassLoader to use for loading the Ressor generated service proxy class.
     */
    public RessorBuilder<ServiceType, DataType> classLoader(ClassLoader classLoader) {
        this.classLoader = classLoader;
        return this;
    }

    public RessorBuilder<ServiceType, DataType> addExtension(ServiceExtension extension) {
        this.extensions.add(extension);
        return this;
    }

    /**
     * Dedicated error handler for the given service
     *
     * @param errorHandler error handler
     */
    public RessorBuilder<ServiceType, DataType> errorHandler(ErrorHandler errorHandler) {
        this.errorHandler = errorHandler;
        return this;
    }

    /**
     * The default arguments for the constructor, which service proxy class will be calling as
     * super(proxyDefaultArguments).
     */
    public RessorBuilder<ServiceType, DataType> proxyDefaultArguments(Object... proxyDefaultArguments) {
        this.proxyDefaultArguments = proxyDefaultArguments;
        return this;
    }

    /**
     * Builds the Ressor service proxy instance. Along with building, it will also conduct the
     * initial data load using {@link Source#load(ResourceId)} )}, either sync or async.
     */
    public ServiceType build() {
        if (source == null) {
            throw new RessorBuilderException("No source instance provided");
        }
        if (translator == null) {
            throw new RessorBuilderException("The data format of the source is unknown, please provide a translator");
        }
        if (resource == null) {
            throw new RessorBuilderException("No Resource ID provided for the given source");
        }
        if (!resource.sourceType().equals(source.getClass())) {
            throw new RessorBuilderException(format("Resource ID (%s) and Source types are incompatible (%s != %s)",
                    resource.getClass().getName(), resource.sourceType().getName(), source.getClass().getName()));
        }
        if (gzipped) {
            translator = TranslatorHelper.gzipped(translator);
        }
        var ctx = ProxyContext.<ServiceType, DataType>builder(type)
                .source(source)
                .resource(resource)
                .classLoader(classLoader)
                .factory(factory)
                .proxyDefaultArguments(proxyDefaultArguments)
                .initialInstance(initialValue)
                .translator(translator)
                .errorHandler(firstNonNull(errorHandler, config.errorHandler()));
        if (extensions.size() > 0) {
            extensions.forEach(ctx::addExtension);
        }
        var proxy = (RessorService<ServiceType>) proxyBuilder.buildProxy(ctx.build());
        if (isAsync) {
            serviceManager.reloadAsync(proxy, source);
        } else {
            serviceManager.reload(proxy, source);
        }
        return (ServiceType) proxy;
    }

}
